

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File Predicate.h &mdash; libomexmeta 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> libomexmeta
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../background.html">Background to Semantic Annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reading_rdf/reading_rdf.html">Reading RDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../writing_rdf/writing_rdf.html">Serializing RDF Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing_rdf/editing_rdf.html">Editing Annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference_index.html">libOmexMeta API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Developers/developers_index.html">Developers Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">libomexmeta</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File Predicate.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/APIReference/program_listing_file_src_omexmeta_Predicate.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-predicate-h">
<span id="program-listing-file-src-omexmeta-predicate-h"></span><h1>Program Listing for File Predicate.h<a class="headerlink" href="#program-listing-for-file-predicate-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_omexmeta_Predicate.h.html#file-src-omexmeta-predicate-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/omexmeta/Predicate.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Created by Ciaran on 4/17/2020.</span>
<span class="c1">//</span>

<span class="cp">#ifndef LIBOMEXMETA_PREDICATE_H</span>
<span class="cp">#define LIBOMEXMETA_PREDICATE_H</span>

<span class="cp">#include</span> <span class="cpf">&quot;World.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;omexmeta/OmexMetaUtils.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;librdf.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">redland</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">omexmeta</span> <span class="p">{</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">NamespaceMap</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * The predicate class creates and stores a URI node.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">Predicate</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">namespace_</span><span class="p">,</span> <span class="n">term_</span><span class="p">,</span> <span class="n">prefix_</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri_</span><span class="p">;</span>
        <span class="n">librdf_node</span> <span class="o">*</span><span class="n">node_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span><span class="s">&quot;All&quot;</span><span class="p">};</span>

        <span class="k">explicit</span> <span class="nf">Predicate</span><span class="p">(</span><span class="n">librdf_node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">Predicate</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief get a map namespaces and prefixes</span>
<span class="cm">         * @returns a unordered_map with namespaces as keys and prefixes as values</span>
<span class="cm">         */</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">namespaceMap</span><span class="p">();</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief construct a Predicate from a namespace, term and prefix portion of a predicate</span>
<span class="cm">         * @param namespace_ the namespace portion of a predicate. i.e. http://biomodels.net/biology-qualifiers/</span>
<span class="cm">         * @param term the last portion of the predicate, i.e. is</span>
<span class="cm">         * @param prefix the prefix that can be used instead of the full namespace, i.e. bqbiol</span>
<span class="cm">         *</span>
<span class="cm">         * http://biomodels.net/biology-qualifiers/is</span>
<span class="cm">         * ---------------------------------------|--</span>
<span class="cm">         *              |                           |</span>
<span class="cm">         *          namespace                      term</span>
<span class="cm">         *</span>
<span class="cm">         *  is equivalent to</span>
<span class="cm">         *</span>
<span class="cm">         * bqbiol:is</span>
<span class="cm">         * ------|--</span>
<span class="cm">         *    |    |</span>
<span class="cm">         * prefix  term</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
        <span class="n">Predicate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">namespace_</span><span class="p">,</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">term</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">prefix</span><span class="p">);</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Predicate</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief get the predicate as a full string</span>
<span class="cm">         * @return a string representing the predicate</span>
<span class="cm">         */</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">();</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief Static method for checking validity of term against valid_terms</span>
<span class="cm">         * @param term the term to validate</span>
<span class="cm">         * @param valid_terms the set of terms to validate term against</span>
<span class="cm">         *</span>
<span class="cm">         * Throws an error when term is not in valid_terms. Used by subclasses</span>
<span class="cm">         * to verify user input.</span>
<span class="cm">         */</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="nf">verify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief check if we have &quot;know&quot; a namespace. Known namespaces are</span>
<span class="cm">         * returned by Predicate::namespaceMap().</span>
<span class="cm">         * @param ns the namespace to check</span>
<span class="cm">         * @return True if we have seen the namespace ns before</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
        <span class="k">static</span> <span class="kt">bool</span> <span class="nf">namespaceKnown</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">ns</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief getter for the node contained by the Predicate object</span>
<span class="cm">         * @return the librdf_node* pointer for the redland libraries under the hood</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">librdf_node</span> <span class="o">*</span><span class="n">getNode</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief stores the valid terms that are allowed in a particular predicate subclass</span>
<span class="cm">         * @return a vector of strings</span>
<span class="cm">         *</span>
<span class="cm">         * Subclasses override this method so they return a complete list of valid terms for their own class</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">getValidTerms</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief getter for the namespace portion of the Predicate</span>
<span class="cm">         * @return the string representing the namespace of the current Predicate</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getNamespace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief getter for term portion of the Predicate</span>
<span class="cm">         * @return the string representing the term portion of the Predicate</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getTerm</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief getter for the prefix portion of the Predicate</span>
<span class="cm">         * @return the string representing the prefix portion of the Predicate</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getPrefix</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief getter for uri</span>
<span class="cm">         *</span>
<span class="cm">         * For developers. Consider removing since str() method does the same thing</span>
<span class="cm">         */</span>
        <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getUri</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief release resources associated with this Predicate.</span>
<span class="cm">         *</span>
<span class="cm">         * Predicate objects contain a librdf_node pointer which</span>
<span class="cm">         * needs to be freed by the caller. If a Predicate is passed</span>
<span class="cm">         * to a Triple object (which most of the time is it),</span>
<span class="cm">         * responsibility for deleting the contained librdf_node</span>
<span class="cm">         * is transferred to the Triple object, which automatically</span>
<span class="cm">         * clears up resources. If not, then it is the callers</span>
<span class="cm">         * responsibility to call this method when they are done with</span>
<span class="cm">         * Predicate instances.</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">freeNode</span><span class="p">();</span>


        <span class="cm">/*</span>
<span class="cm">         * @brief utility for checking whether the uri in @parameter predicate</span>
<span class="cm">         * has a namespace that we already know. If found, the namespace is</span>
<span class="cm">         * added to @parameter serializer</span>
<span class="cm">         */</span>
        <span class="k">static</span> <span class="kt">void</span>
        <span class="nf">addSeenNamespaceToSerializer</span><span class="p">(</span><span class="n">librdf_world</span> <span class="o">*</span><span class="n">world</span><span class="p">,</span> <span class="n">librdf_serializer</span> <span class="o">*</span><span class="n">serializer</span><span class="p">,</span> <span class="n">librdf_node</span> <span class="o">*</span><span class="n">predicate</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief replace the current librdf_node assicated with</span>
<span class="cm">         * this Predicate with node</span>
<span class="cm">         * @param node the new librdf_node pointer to use in the Predicate</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">setNode</span><span class="p">(</span><span class="n">librdf_node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * @brief make a shared pointer from this Predicate</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
<span class="c1">//        std::shared_ptr&lt;Predicate&gt; makeShared();</span>

    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * @class Subclass of Predicate specifically for predicates from the</span>
<span class="cm">     * BiomodelsBiologyQualifier set of predicates. All</span>
<span class="cm">     * BiomodelsBiologyQualifier predicates have the namespace</span>
<span class="cm">     * `http://biomodels.net/biology-qualifiers/` and a `bqbiol` prefix.</span>
<span class="cm">     *</span>
<span class="cm">     * @example</span>
<span class="cm">     * @code</span>
<span class="cm">     * BiomodelBiologyQualifier is(&quot;is&quot;);</span>
<span class="cm">     * std::cout &lt;&lt; is.str() &lt;&lt; std::endl;</span>
<span class="cm">     * @endcode</span>
<span class="cm">     * will output</span>
<span class="cm">     *   http://biomodels.net/biology-qualifiers/is</span>
<span class="cm">     * to console.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">BiomodelsBiologyQualifier</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Predicate</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span>
                <span class="s">&quot;is&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasPart&quot;</span><span class="p">,</span>
                <span class="s">&quot;isPartOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;isVersionOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasVersion&quot;</span><span class="p">,</span>
                <span class="s">&quot;isHomologTo&quot;</span><span class="p">,</span>
                <span class="s">&quot;isDescribedBy&quot;</span><span class="p">,</span>
                <span class="s">&quot;isEncodedBy&quot;</span><span class="p">,</span>
                <span class="s">&quot;encodes&quot;</span><span class="p">,</span>
                <span class="s">&quot;occursIn&quot;</span><span class="p">,</span>
                <span class="s">&quot;isVersionOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;isPropertyOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasTaxon&quot;</span>
        <span class="p">};</span>

        <span class="n">BiomodelsBiologyQualifier</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">BiomodelsBiologyQualifier</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">verify</span><span class="p">();</span>

<span class="c1">//        std::shared_ptr&lt;BiomodelsBiologyQualifier&gt; makeShared();</span>

    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * @class Subclass of Predicate specifically for predicates from the</span>
<span class="cm">     * BiomodelsModelQualifier set of predicates. All</span>
<span class="cm">     * BiomodelsModelQualifier predicates have the namespace</span>
<span class="cm">     * `http://biomodels.net/model-qualifiers/` and a `bqmodel` prefix.</span>
<span class="cm">     *</span>
<span class="cm">     * @example</span>
<span class="cm">     * @code</span>
<span class="cm">     * BiomodelModelQualifier isDerivedFrom(&quot;isDerivedFrom&quot;);</span>
<span class="cm">     * std::cout &lt;&lt; isDerivedFrom.str() &lt;&lt; std::endl;</span>
<span class="cm">     * @endcode</span>
<span class="cm">     * will output</span>
<span class="cm">     *   http://biomodels.net/model-qualifiers/isDerivedFrom</span>
<span class="cm">     * to console.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">BiomodelsModelQualifier</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Predicate</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span>
                <span class="s">&quot;isDerivedFrom&quot;</span><span class="p">,</span>
                <span class="s">&quot;isDescribedBy&quot;</span><span class="p">,</span>
                <span class="s">&quot;isInstanceOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasInstance&quot;</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="n">BiomodelsModelQualifier</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">BiomodelsModelQualifier</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">verify</span><span class="p">();</span>

<span class="c1">//        std::shared_ptr&lt;BiomodelsModelQualifier&gt; makeShared();</span>

    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * @class Subclass of Predicate specifically for predicates from the</span>
<span class="cm">     * DCTerm set of predicates. All</span>
<span class="cm">     * DCTerm predicates have the namespace</span>
<span class="cm">     * `https://dublincore.org/specifications/dublin-core/dcmi-terms/` and a `bqmodel` prefix.</span>
<span class="cm">     *</span>
<span class="cm">     * @example</span>
<span class="cm">     * @code</span>
<span class="cm">     * DCTerm description(&quot;Description&quot;);</span>
<span class="cm">     * std::cout &lt;&lt; description.str() &lt;&lt; std::endl;</span>
<span class="cm">     * @endcode</span>
<span class="cm">     * will output</span>
<span class="cm">     *   &quot;https://dublincore.org/specifications/dublin-core/dcmi-terms/Description&quot;</span>
<span class="cm">     * to console.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">DCTerm</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Predicate</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span>
                <span class="s">&quot;abstract&quot;</span><span class="p">,</span> <span class="s">&quot;accessRights&quot;</span><span class="p">,</span> <span class="s">&quot;accrualMethod&quot;</span><span class="p">,</span> <span class="s">&quot;accrualPeriodicity&quot;</span><span class="p">,</span> <span class="s">&quot;accrualPolicy&quot;</span><span class="p">,</span> <span class="s">&quot;alternative&quot;</span><span class="p">,</span>
                <span class="s">&quot;audience&quot;</span><span class="p">,</span> <span class="s">&quot;available&quot;</span><span class="p">,</span> <span class="s">&quot;bibliographicCitation&quot;</span><span class="p">,</span> <span class="s">&quot;conformsTo&quot;</span><span class="p">,</span> <span class="s">&quot;contributor&quot;</span><span class="p">,</span> <span class="s">&quot;coverage&quot;</span><span class="p">,</span> <span class="s">&quot;created&quot;</span><span class="p">,</span>
                <span class="s">&quot;creator&quot;</span><span class="p">,</span> <span class="s">&quot;date&quot;</span><span class="p">,</span> <span class="s">&quot;dateAccepted&quot;</span><span class="p">,</span> <span class="s">&quot;dateCopyrighted&quot;</span><span class="p">,</span> <span class="s">&quot;dateSubmitted&quot;</span><span class="p">,</span> <span class="s">&quot;description&quot;</span><span class="p">,</span> <span class="s">&quot;educationLevel&quot;</span><span class="p">,</span>
                <span class="s">&quot;extent&quot;</span><span class="p">,</span> <span class="s">&quot;format&quot;</span><span class="p">,</span> <span class="s">&quot;hasFormat&quot;</span><span class="p">,</span> <span class="s">&quot;hasPart&quot;</span><span class="p">,</span> <span class="s">&quot;hasVersion&quot;</span><span class="p">,</span> <span class="s">&quot;identifier&quot;</span><span class="p">,</span> <span class="s">&quot;instructionalMethod&quot;</span><span class="p">,</span>
                <span class="s">&quot;isFormatOf&quot;</span><span class="p">,</span> <span class="s">&quot;isPartOf&quot;</span><span class="p">,</span> <span class="s">&quot;isReferencedBy&quot;</span><span class="p">,</span> <span class="s">&quot;isReplacedBy&quot;</span><span class="p">,</span> <span class="s">&quot;isRequiredBy&quot;</span><span class="p">,</span> <span class="s">&quot;issued&quot;</span><span class="p">,</span> <span class="s">&quot;isVersionOf&quot;</span><span class="p">,</span>
                <span class="s">&quot;language&quot;</span><span class="p">,</span> <span class="s">&quot;license&quot;</span><span class="p">,</span> <span class="s">&quot;mediator&quot;</span><span class="p">,</span> <span class="s">&quot;medium&quot;</span><span class="p">,</span> <span class="s">&quot;modified&quot;</span><span class="p">,</span> <span class="s">&quot;provenance&quot;</span><span class="p">,</span> <span class="s">&quot;publisher&quot;</span><span class="p">,</span> <span class="s">&quot;references&quot;</span><span class="p">,</span>
                <span class="s">&quot;relation&quot;</span><span class="p">,</span> <span class="s">&quot;replaces&quot;</span><span class="p">,</span> <span class="s">&quot;requires&quot;</span><span class="p">,</span> <span class="s">&quot;rights&quot;</span><span class="p">,</span> <span class="s">&quot;rightsHolder&quot;</span><span class="p">,</span> <span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="s">&quot;spatial&quot;</span><span class="p">,</span> <span class="s">&quot;subject&quot;</span><span class="p">,</span>
                <span class="s">&quot;tableOfContents&quot;</span><span class="p">,</span> <span class="s">&quot;temporal&quot;</span><span class="p">,</span> <span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="s">&quot;valid&quot;</span><span class="p">,};</span>

        <span class="n">DCTerm</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">DCTerm</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">verify</span><span class="p">();</span>

<span class="c1">//        std::shared_ptr&lt;DCTerm&gt; makeShared() ;</span>

    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * @class Subclass of Predicate specifically for predicates from the</span>
<span class="cm">     * SemSim set of predicates. All</span>
<span class="cm">     * SemSim predicates have the namespace</span>
<span class="cm">     * `http://www.bhi.washington.edu/semsim#` and a `bqmodel` prefix.</span>
<span class="cm">     *</span>
<span class="cm">     * @example</span>
<span class="cm">     * @code</span>
<span class="cm">     * SemSim hasSourceParticipant(&quot;hasSourceParticipant&quot;);</span>
<span class="cm">     * std::cout &lt;&lt; hasSourceParticipant.str() &lt;&lt; std::endl;</span>
<span class="cm">     * @endcode</span>
<span class="cm">     * will output</span>
<span class="cm">     *   &quot;http://www.bhi.washington.edu/semsim#hasSourceParticipant&quot;</span>
<span class="cm">     * to console.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">SemSim</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Predicate</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span>
                <span class="s">&quot;hasSourceParticipant&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasSinkParticipant&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasMediatorParticipant&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasMultiplier&quot;</span><span class="p">,</span>
                <span class="s">&quot;hasPhysicalEntityReference&quot;</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="n">SemSim</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">SemSim</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">verify</span><span class="p">();</span>

    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * @class Subclass of Predicate specifically for predicates from the</span>
<span class="cm">     * Foaf set of predicates. All</span>
<span class="cm">     *  predicates have the namespace</span>
<span class="cm">     * `http://www.bhi.washington.edu/semsim#` and a `bqmodel` prefix.</span>
<span class="cm">     *</span>
<span class="cm">     * @example</span>
<span class="cm">     * @code</span>
<span class="cm">     * SemSim hasSourceParticipant(&quot;hasSourceParticipant&quot;);</span>
<span class="cm">     * std::cout &lt;&lt; hasSourceParticipant.str() &lt;&lt; std::endl;</span>
<span class="cm">     * @endcode</span>
<span class="cm">     * will output</span>
<span class="cm">     *   &quot;http://www.bhi.washington.edu/semsim#hasSourceParticipant&quot;</span>
<span class="cm">     * to console.</span>
<span class="cm">     */</span>
    <span class="k">class</span> <span class="nc">Foaf</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Predicate</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">valid_terms_</span><span class="p">{</span>
                <span class="s">&quot;Agent&quot;</span><span class="p">,</span> <span class="s">&quot;Person&quot;</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="s">&quot;img&quot;</span><span class="p">,</span> <span class="s">&quot;depiction&quot;</span><span class="p">,</span> <span class="s">&quot;familyName&quot;</span><span class="p">,</span> <span class="s">&quot;givenName&quot;</span><span class="p">,</span> <span class="s">&quot;knows&quot;</span><span class="p">,</span>
                <span class="s">&quot;based_near&quot;</span><span class="p">,</span> <span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="s">&quot;made&quot;</span><span class="p">,</span> <span class="s">&quot;primaryTopic&quot;</span><span class="p">,</span> <span class="s">&quot;Project&quot;</span><span class="p">,</span> <span class="s">&quot;Organization&quot;</span><span class="p">,</span> <span class="s">&quot;Group&quot;</span><span class="p">,</span> <span class="s">&quot;member&quot;</span><span class="p">,</span>
                <span class="s">&quot;Document&quot;</span><span class="p">,</span> <span class="s">&quot;Image&quot;</span><span class="p">,</span> <span class="s">&quot;nick&quot;</span><span class="p">,</span> <span class="s">&quot;mbox&quot;</span><span class="p">,</span> <span class="s">&quot;homepage&quot;</span><span class="p">,</span> <span class="s">&quot;weblog&quot;</span><span class="p">,</span> <span class="s">&quot;openid&quot;</span><span class="p">,</span> <span class="s">&quot;jabberID&quot;</span><span class="p">,</span> <span class="s">&quot;mbox_sha1sum&quot;</span><span class="p">,</span>
                <span class="s">&quot;interest&quot;</span><span class="p">,</span> <span class="s">&quot;topic_interest&quot;</span><span class="p">,</span> <span class="s">&quot;topic&quot;</span><span class="p">,</span> <span class="s">&quot;workplaceHomepage&quot;</span><span class="p">,</span> <span class="s">&quot;workInfoHomepage&quot;</span><span class="p">,</span> <span class="s">&quot;schoolHomepage&quot;</span><span class="p">,</span>
                <span class="s">&quot;publications&quot;</span><span class="p">,</span> <span class="s">&quot;currentProject&quot;</span><span class="p">,</span> <span class="s">&quot;pastProject&quot;</span><span class="p">,</span> <span class="s">&quot;account&quot;</span><span class="p">,</span> <span class="s">&quot;OnlineAccount&quot;</span><span class="p">,</span> <span class="s">&quot;accountName&quot;</span><span class="p">,</span>
                <span class="s">&quot;accountServiceHomepage&quot;</span><span class="p">,</span> <span class="s">&quot;PersonalProfileDocument&quot;</span><span class="p">,</span> <span class="s">&quot;tipjar&quot;</span><span class="p">,</span> <span class="s">&quot;sha1&quot;</span><span class="p">,</span> <span class="s">&quot;thumbnail&quot;</span><span class="p">,</span> <span class="s">&quot;logo&quot;</span><span class="p">,};</span>

        <span class="n">Foaf</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">Foaf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">verify</span><span class="p">();</span>

<span class="c1">//        std::shared_ptr&lt;SemSim&gt; makeShared() ;</span>

    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span> <span class="n">PredicatePtr</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span> <span class="n">Predicates</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PredicatePtr</span><span class="o">&gt;</span> <span class="n">PredicatePtrs</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * @brief Convenience function for creation of objects in the</span>
<span class="cm">     * predicate hierachy.</span>
<span class="cm">     * @param namespace_ one of 8 namespaces, a long and short form string for each Predicate subtype.</span>
<span class="cm">     * @param term the term portion of the predicate</span>
<span class="cm">     *</span>
<span class="cm">     * @details namespace_ argument is:</span>
<span class="cm">     *  - bqbiol or BiomodelsBiologyQualifier for BiomodelsBiologyQualifier</span>
<span class="cm">     *  - bqm or BiomodelsModelQualifier for BiomodelsModelQualifier</span>
<span class="cm">     *  - ss or SemSim for SemSim</span>
<span class="cm">     *  - dc or DCTerm for DCTerm</span>
<span class="cm">     *</span>
<span class="cm">     * @return a shared_ptr to a object from the predicate heirachy.</span>
<span class="cm">     */</span>
    <span class="n">PredicatePtr</span> <span class="nf">PredicateFactory</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">namespace_</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>

<span class="p">}</span>


<span class="cp">#endif </span><span class="c1">//LIBOMEXMETA_PREDICATE_H</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ciaran Welsh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>