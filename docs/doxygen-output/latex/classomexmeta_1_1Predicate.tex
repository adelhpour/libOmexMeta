\hypertarget{classomexmeta_1_1Predicate}{}\section{omexmeta\+:\+:Predicate Class Reference}
\label{classomexmeta_1_1Predicate}\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}


{\ttfamily \#include $<$Predicate.\+h$>$}

Inheritance diagram for omexmeta\+:\+:Predicate\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=0.978166cm]{classomexmeta_1_1Predicate}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}{Predicate} (const std\+::string \&namespace\+\_\+, std\+::string term, std\+::string prefix)
\begin{DoxyCompactList}\small\item\em construct a \hyperlink{classomexmeta_1_1Predicate}{Predicate} from a namespace, term and prefix portion of a predicate \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a5db1e6150f8cfd7605e82996e2aebb50}\label{classomexmeta_1_1Predicate_a5db1e6150f8cfd7605e82996e2aebb50}} 
bool {\bfseries operator==} (const \hyperlink{classomexmeta_1_1Predicate}{Predicate} \&rhs) const
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a7bf4b8769eb9801eb26cc976723b56f2}\label{classomexmeta_1_1Predicate_a7bf4b8769eb9801eb26cc976723b56f2}} 
bool {\bfseries operator!=} (const \hyperlink{classomexmeta_1_1Predicate}{Predicate} \&rhs) const
\item 
std\+::string \hyperlink{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}{str} ()
\begin{DoxyCompactList}\small\item\em get the predicate as a full string \end{DoxyCompactList}\item 
librdf\+\_\+node $\ast$ \hyperlink{classomexmeta_1_1Predicate_a144efc75a923b9d85b9f8eaccf0400bb}{get\+Node} () const
\begin{DoxyCompactList}\small\item\em getter for the node contained by the \hyperlink{classomexmeta_1_1Predicate}{Predicate} object \end{DoxyCompactList}\item 
const std\+::vector$<$ std\+::string $>$ \& \hyperlink{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}{get\+Valid\+Terms} () const
\begin{DoxyCompactList}\small\item\em stores the valid terms that are allowed in a particular predicate subclass \end{DoxyCompactList}\item 
const std\+::string \& \hyperlink{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}{get\+Namespace} () const
\begin{DoxyCompactList}\small\item\em getter for the namespace portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} \end{DoxyCompactList}\item 
const std\+::string \& \hyperlink{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}{get\+Term} () const
\begin{DoxyCompactList}\small\item\em getter for term portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} \end{DoxyCompactList}\item 
const std\+::string \& \hyperlink{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}{get\+Prefix} () const
\begin{DoxyCompactList}\small\item\em getter for the prefix portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} \end{DoxyCompactList}\item 
const std\+::string \& \hyperlink{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}{get\+Uri} () const
\begin{DoxyCompactList}\small\item\em getter for uri \end{DoxyCompactList}\item 
void \hyperlink{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}{free\+Node} ()
\begin{DoxyCompactList}\small\item\em release resources associated with this \hyperlink{classomexmeta_1_1Predicate}{Predicate}. \end{DoxyCompactList}\item 
void \hyperlink{classomexmeta_1_1Predicate_a0bf6030510247a6999d81cada92c1e51}{set\+Node} (librdf\+\_\+node $\ast$node)
\begin{DoxyCompactList}\small\item\em replace the current librdf\+\_\+node assicated with this \hyperlink{classomexmeta_1_1Predicate}{Predicate} with node \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::unordered\+\_\+map$<$ std\+::string, std\+::string $>$ \hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{namespace\+Map} ()
\begin{DoxyCompactList}\small\item\em get a map namespaces and prefixes \end{DoxyCompactList}\item 
static void \hyperlink{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}{verify} (std\+::vector$<$ std\+::string $>$ valid\+\_\+terms, const std\+::string \&term)
\begin{DoxyCompactList}\small\item\em Static method for checking validity of term against valid\+\_\+terms. \end{DoxyCompactList}\item 
static bool \hyperlink{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}{namespace\+Known} (const std\+::string \&ns)
\begin{DoxyCompactList}\small\item\em check if we have \char`\"{}know\char`\"{} a namespace. Known namespaces are returned by \hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{Predicate\+::namespace\+Map()}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a4cda551beb4e1354ac56d692f0eb78cd}\label{classomexmeta_1_1Predicate_a4cda551beb4e1354ac56d692f0eb78cd}} 
static void \hyperlink{classomexmeta_1_1Predicate_a4cda551beb4e1354ac56d692f0eb78cd}{add\+Seen\+Namespace\+To\+Serializer} (librdf\+\_\+world $\ast$world, librdf\+\_\+serializer $\ast$serializer, librdf\+\_\+node $\ast$predicate)
\begin{DoxyCompactList}\small\item\em utility for checking whether the uri in  predicate has a namespace that we already know. If found, the namespace is added to  serializer \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a157c4e95f9869d4f22cd07332ff7621a}\label{classomexmeta_1_1Predicate_a157c4e95f9869d4f22cd07332ff7621a}} 
{\bfseries Predicate} (librdf\+\_\+node $\ast$node)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}\label{classomexmeta_1_1Predicate_afc79b0cc43eb11e4bc2fe0b305e551bc}} 
std\+::string {\bfseries namespace\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ab626a5fd9fa8f302767d4ca544a9eff2}\label{classomexmeta_1_1Predicate_ab626a5fd9fa8f302767d4ca544a9eff2}} 
std\+::string {\bfseries term\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a5dfbbc85f7bdc5a3e4da72913f6ce306}\label{classomexmeta_1_1Predicate_a5dfbbc85f7bdc5a3e4da72913f6ce306}} 
std\+::string {\bfseries prefix\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a4fe359b93a9dea9b60f7bc28c1aa913b}\label{classomexmeta_1_1Predicate_a4fe359b93a9dea9b60f7bc28c1aa913b}} 
std\+::string {\bfseries uri\+\_\+}
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ad0548a6d31dbc6f32734032b1540e58f}\label{classomexmeta_1_1Predicate_ad0548a6d31dbc6f32734032b1540e58f}} 
librdf\+\_\+node $\ast$ {\bfseries node\+\_\+} = nullptr
\item 
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a14ae7768fbd3aaf444bcde8650910c0b}\label{classomexmeta_1_1Predicate_a14ae7768fbd3aaf444bcde8650910c0b}} 
std\+::vector$<$ std\+::string $>$ \hyperlink{classomexmeta_1_1Predicate_a14ae7768fbd3aaf444bcde8650910c0b}{valid\+\_\+terms\+\_\+} \{\char`\"{}All\char`\"{}\}
\begin{DoxyCompactList}\small\item\em predicates can only have type uri \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The predicate class creates and stores a U\+RI node. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}\label{classomexmeta_1_1Predicate_ad5a91eb29204202d2f18816d09677622}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!Predicate@{Predicate}}
\index{Predicate@{Predicate}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{Predicate()}{Predicate()}}
{\footnotesize\ttfamily omexmeta\+::\+Predicate\+::\+Predicate (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{namespace\+\_\+,  }\item[{std\+::string}]{term,  }\item[{std\+::string}]{prefix }\end{DoxyParamCaption})}



construct a \hyperlink{classomexmeta_1_1Predicate}{Predicate} from a namespace, term and prefix portion of a predicate 


\begin{DoxyParams}{Parameters}
{\em namespace\+\_\+} & the namespace portion of a predicate. i.\+e. \href{http://biomodels.net/biology-qualifiers/}{\tt http\+://biomodels.\+net/biology-\/qualifiers/} \\
\hline
{\em term} & the last portion of the predicate, i.\+e. is \\
\hline
{\em prefix} & the prefix that can be used instead of the full namespace, i.\+e. bqbiol\\
\hline
\end{DoxyParams}
\href{http://biomodels.net/biology-qualifiers/is}{\tt http\+://biomodels.\+net/biology-\/qualifiers/is} -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$-- $\vert$ $\vert$ namespace term

is equivalent to

bqbiol\+:is -\/-\/-\/---$\vert$-- $\vert$ $\vert$ prefix term 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}\label{classomexmeta_1_1Predicate_a718a37ff90ac0f2d7cc129e8351a2c7b}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!free\+Node@{free\+Node}}
\index{free\+Node@{free\+Node}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{free\+Node()}{freeNode()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::free\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



release resources associated with this \hyperlink{classomexmeta_1_1Predicate}{Predicate}. 

\hyperlink{classomexmeta_1_1Predicate}{Predicate} objects contain a librdf\+\_\+node pointer which needs to be freed by the caller. If a \hyperlink{classomexmeta_1_1Predicate}{Predicate} is passed to a \hyperlink{classomexmeta_1_1Triple}{Triple} object (which most of the time is it), responsibility for deleting the contained librdf\+\_\+node is transferred to the \hyperlink{classomexmeta_1_1Triple}{Triple} object, which automatically clears up resources. If not, then it is the callers responsibility to call this method when they are done with \hyperlink{classomexmeta_1_1Predicate}{Predicate} instances. \mbox{\Hypertarget{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}\label{classomexmeta_1_1Predicate_add4ab1cd86f83de3512279bbfdad947c}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Namespace@{get\+Namespace}}
\index{get\+Namespace@{get\+Namespace}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Namespace()}{getNamespace()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Namespace (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for the namespace portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} 

\begin{DoxyReturn}{Returns}
the string representing the namespace of the current \hyperlink{classomexmeta_1_1Predicate}{Predicate} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a144efc75a923b9d85b9f8eaccf0400bb}\label{classomexmeta_1_1Predicate_a144efc75a923b9d85b9f8eaccf0400bb}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Node@{get\+Node}}
\index{get\+Node@{get\+Node}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Node()}{getNode()}}
{\footnotesize\ttfamily librdf\+\_\+node $\ast$ omexmeta\+::\+Predicate\+::get\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for the node contained by the \hyperlink{classomexmeta_1_1Predicate}{Predicate} object 

\begin{DoxyReturn}{Returns}
the librdf\+\_\+node$\ast$ pointer for the redland libraries under the hood 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}\label{classomexmeta_1_1Predicate_a0147e977f71604db05763815ae6b553f}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Prefix@{get\+Prefix}}
\index{get\+Prefix@{get\+Prefix}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Prefix()}{getPrefix()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Prefix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for the prefix portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} 

\begin{DoxyReturn}{Returns}
the string representing the prefix portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}\label{classomexmeta_1_1Predicate_a54a15176bd697d37d00573bf86954630}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Term@{get\+Term}}
\index{get\+Term@{get\+Term}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Term()}{getTerm()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Term (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for term portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} 

\begin{DoxyReturn}{Returns}
the string representing the term portion of the \hyperlink{classomexmeta_1_1Predicate}{Predicate} 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}\label{classomexmeta_1_1Predicate_a27fa7d62ad9a5182f3dd642bc61c8d9f}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Uri@{get\+Uri}}
\index{get\+Uri@{get\+Uri}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Uri()}{getUri()}}
{\footnotesize\ttfamily const std\+::string \& omexmeta\+::\+Predicate\+::get\+Uri (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



getter for uri 

For developers. Consider removing since \hyperlink{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}{str()} method does the same thing \mbox{\Hypertarget{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}\label{classomexmeta_1_1Predicate_aee19b8fc8b21f8e5ffd5b64691e1e530}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!get\+Valid\+Terms@{get\+Valid\+Terms}}
\index{get\+Valid\+Terms@{get\+Valid\+Terms}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{get\+Valid\+Terms()}{getValidTerms()}}
{\footnotesize\ttfamily const std\+::vector$<$ std\+::string $>$ \& omexmeta\+::\+Predicate\+::get\+Valid\+Terms (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



stores the valid terms that are allowed in a particular predicate subclass 

\begin{DoxyReturn}{Returns}
a vector of strings
\end{DoxyReturn}
Subclasses override this method so they return a complete list of valid terms for their own class \mbox{\Hypertarget{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}\label{classomexmeta_1_1Predicate_a8381c8b0c7bbaa27de29608cbff08bf5}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!namespace\+Known@{namespace\+Known}}
\index{namespace\+Known@{namespace\+Known}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{namespace\+Known()}{namespaceKnown()}}
{\footnotesize\ttfamily bool omexmeta\+::\+Predicate\+::namespace\+Known (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{ns }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



check if we have \char`\"{}know\char`\"{} a namespace. Known namespaces are returned by \hyperlink{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}{Predicate\+::namespace\+Map()}. 


\begin{DoxyParams}{Parameters}
{\em ns} & the namespace to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if we have seen the namespace ns before 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}\label{classomexmeta_1_1Predicate_a1291e3cd9727871f568e864e0f5af3f0}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!namespace\+Map@{namespace\+Map}}
\index{namespace\+Map@{namespace\+Map}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{namespace\+Map()}{namespaceMap()}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$ std\+::string, std\+::string $>$ omexmeta\+::\+Predicate\+::namespace\+Map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



get a map namespaces and prefixes 

\begin{DoxyReturn}{Returns}
a unordered\+\_\+map with namespaces as keys and prefixes as values 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a0bf6030510247a6999d81cada92c1e51}\label{classomexmeta_1_1Predicate_a0bf6030510247a6999d81cada92c1e51}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!set\+Node@{set\+Node}}
\index{set\+Node@{set\+Node}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{set\+Node()}{setNode()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::set\+Node (\begin{DoxyParamCaption}\item[{librdf\+\_\+node $\ast$}]{node }\end{DoxyParamCaption})}



replace the current librdf\+\_\+node assicated with this \hyperlink{classomexmeta_1_1Predicate}{Predicate} with node 


\begin{DoxyParams}{Parameters}
{\em node} & the new librdf\+\_\+node pointer to use in the \hyperlink{classomexmeta_1_1Predicate}{Predicate} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}\label{classomexmeta_1_1Predicate_a9d51ebf565f39fb4d6d4f58c1b030edf}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!str@{str}}
\index{str@{str}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{str()}{str()}}
{\footnotesize\ttfamily std\+::string omexmeta\+::\+Predicate\+::str (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



get the predicate as a full string 

\begin{DoxyReturn}{Returns}
a string representing the predicate 
\end{DoxyReturn}
\mbox{\Hypertarget{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}\label{classomexmeta_1_1Predicate_a1e7e59b8a48c9f89eeec73f3bbaea19c}} 
\index{omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}!verify@{verify}}
\index{verify@{verify}!omexmeta\+::\+Predicate@{omexmeta\+::\+Predicate}}
\subsubsection{\texorpdfstring{verify()}{verify()}}
{\footnotesize\ttfamily void omexmeta\+::\+Predicate\+::verify (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$}]{valid\+\_\+terms,  }\item[{const std\+::string \&}]{term }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Static method for checking validity of term against valid\+\_\+terms. 


\begin{DoxyParams}{Parameters}
{\em term} & the term to validate \\
\hline
{\em valid\+\_\+terms} & the set of terms to validate term against\\
\hline
\end{DoxyParams}
Throws an error when term is not in valid\+\_\+terms. Used by subclasses to verify user input. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/omexmeta/Predicate.\+h\item 
src/omexmeta/Predicate.\+cpp\end{DoxyCompactItemize}
